# Annealing Library
![annealing logo](media/logo1.png)

## Annealing algorithm in general
https://en.wikipedia.org/wiki/Simulated_annealing

## Parallel Simulated Annealing
How to speed up annealing algorithm with the most efficiency. The answer is not really perplex: adding multithreading.
The problem is in the core idea of the algorithm.
It is not like local optimization, where you ("land on the surface in random places") generating many random initializations and then protruding to the local minimum from each one.
In this case parallel idea is extremely simple, just computing each way after landing in parallel.
But in our case it is something different. Annealing requires us to use sequential computations because all the states of the algorithm are being generated by the previous ones.
Each state has two options:
1) apply changes (accept)
2) stay untouched (reject)

Initial state is generated only one time.

So we can not compute the next state without being sure that it would be chosen, or can we?
So the idea is to use the technique of speculative computations in which work is performed before it is known whether it is need.

#### First algorithm (inefficient)
Initially we will start with root node and only one process after generating it we will generate two new nodes - rejected and accepted.
Each node represents its own thread and will be denoting the root one but for its subtree, so its functions are the same, and it has same is root behaviour.
In general, it is independent.
![slow algorithm and how it works](media/sluggish_algorithm_1.png)
Accepted node is a new state and rejected is the same as its parent (but with other temperature it is changing no matter what type the node is).
So now these nodes are behaving independently while root node is calculating evaluation function (the heaviest part of computations).
When root node finishes with its work it decides what child to choose.
Now only goal that remains for root node is to kill not chosen child process and all of its subtree.
So root process goes through all of not chosen child subtree and kills all its processes or another approach is to kill only child and then it will kill its own and so on.
Finally, root node process should eliminate itself.
![slow algorithm and how elimination works](media/sluggish_algorithm_2.png)
This algorithm is not efficient enough. In this tree rejected edges grows much faster than accepted so it won't be enough threads to cover all the vertices that we need.
Moreover, killing processes is excessively large amount of work. And with the number of threads growing the optimization is getting less efficient. 

#### Algorithm that I use in this project

## Usage instruction :)

## Resources
https://www.sciencedirect.com/science/article/pii/0895717789902021
https://www.math.spbu.ru/user/gran/sb1/lopatin.pdf
https://dl.acm.org/doi/pdf/10.5555/1882757.1882790